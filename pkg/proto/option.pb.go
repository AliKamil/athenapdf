// Code generated by protoc-gen-go. DO NOT EDIT.
// source: option.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Option struct {
	// Types that are valid to be assigned to Value:
	//	*Option_DoubleValue
	//	*Option_Int64Value
	//	*Option_Uint64Value
	//	*Option_BoolValue
	//	*Option_StringValue
	//	*Option_BytesValue
	Value isOption_Value `protobuf_oneof:"value"`
}

func (m *Option) Reset()                    { *m = Option{} }
func (m *Option) String() string            { return proto1.CompactTextString(m) }
func (*Option) ProtoMessage()               {}
func (*Option) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

type isOption_Value interface {
	isOption_Value()
}

type Option_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,1,opt,name=double_value,json=doubleValue,oneof"`
}
type Option_Int64Value struct {
	Int64Value int64 `protobuf:"varint,2,opt,name=int64_value,json=int64Value,oneof"`
}
type Option_Uint64Value struct {
	Uint64Value uint64 `protobuf:"varint,3,opt,name=uint64_value,json=uint64Value,oneof"`
}
type Option_BoolValue struct {
	BoolValue bool `protobuf:"varint,4,opt,name=bool_value,json=boolValue,oneof"`
}
type Option_StringValue struct {
	StringValue string `protobuf:"bytes,5,opt,name=string_value,json=stringValue,oneof"`
}
type Option_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,6,opt,name=bytes_value,json=bytesValue,proto3,oneof"`
}

func (*Option_DoubleValue) isOption_Value() {}
func (*Option_Int64Value) isOption_Value()  {}
func (*Option_Uint64Value) isOption_Value() {}
func (*Option_BoolValue) isOption_Value()   {}
func (*Option_StringValue) isOption_Value() {}
func (*Option_BytesValue) isOption_Value()  {}

func (m *Option) GetValue() isOption_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Option) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*Option_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *Option) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*Option_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *Option) GetUint64Value() uint64 {
	if x, ok := m.GetValue().(*Option_Uint64Value); ok {
		return x.Uint64Value
	}
	return 0
}

func (m *Option) GetBoolValue() bool {
	if x, ok := m.GetValue().(*Option_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *Option) GetStringValue() string {
	if x, ok := m.GetValue().(*Option_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Option) GetBytesValue() []byte {
	if x, ok := m.GetValue().(*Option_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Option) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Option_OneofMarshaler, _Option_OneofUnmarshaler, _Option_OneofSizer, []interface{}{
		(*Option_DoubleValue)(nil),
		(*Option_Int64Value)(nil),
		(*Option_Uint64Value)(nil),
		(*Option_BoolValue)(nil),
		(*Option_StringValue)(nil),
		(*Option_BytesValue)(nil),
	}
}

func _Option_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Option)
	// value
	switch x := m.Value.(type) {
	case *Option_DoubleValue:
		b.EncodeVarint(1<<3 | proto1.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case *Option_Int64Value:
		b.EncodeVarint(2<<3 | proto1.WireVarint)
		b.EncodeVarint(uint64(x.Int64Value))
	case *Option_Uint64Value:
		b.EncodeVarint(3<<3 | proto1.WireVarint)
		b.EncodeVarint(uint64(x.Uint64Value))
	case *Option_BoolValue:
		t := uint64(0)
		if x.BoolValue {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto1.WireVarint)
		b.EncodeVarint(t)
	case *Option_StringValue:
		b.EncodeVarint(5<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.StringValue)
	case *Option_BytesValue:
		b.EncodeVarint(6<<3 | proto1.WireBytes)
		b.EncodeRawBytes(x.BytesValue)
	case nil:
	default:
		return fmt.Errorf("Option.Value has unexpected type %T", x)
	}
	return nil
}

func _Option_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Option)
	switch tag {
	case 1: // value.double_value
		if wire != proto1.WireFixed64 {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Option_DoubleValue{math.Float64frombits(x)}
		return true, err
	case 2: // value.int64_value
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Option_Int64Value{int64(x)}
		return true, err
	case 3: // value.uint64_value
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Option_Uint64Value{x}
		return true, err
	case 4: // value.bool_value
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Option_BoolValue{x != 0}
		return true, err
	case 5: // value.string_value
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Option_StringValue{x}
		return true, err
	case 6: // value.bytes_value
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Value = &Option_BytesValue{x}
		return true, err
	default:
		return false, nil
	}
}

func _Option_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Option)
	// value
	switch x := m.Value.(type) {
	case *Option_DoubleValue:
		n += proto1.SizeVarint(1<<3 | proto1.WireFixed64)
		n += 8
	case *Option_Int64Value:
		n += proto1.SizeVarint(2<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Int64Value))
	case *Option_Uint64Value:
		n += proto1.SizeVarint(3<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Uint64Value))
	case *Option_BoolValue:
		n += proto1.SizeVarint(4<<3 | proto1.WireVarint)
		n += 1
	case *Option_StringValue:
		n += proto1.SizeVarint(5<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case *Option_BytesValue:
		n += proto1.SizeVarint(6<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.BytesValue)))
		n += len(x.BytesValue)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto1.RegisterType((*Option)(nil), "proto.Option")
}

func init() { proto1.RegisterFile("option.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 189 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0xcf, 0xcf, 0x0a, 0x82, 0x40,
	0x10, 0xc7, 0x71, 0x27, 0xff, 0x94, 0xe3, 0x9e, 0x3c, 0x75, 0x6b, 0xcb, 0xcb, 0x9e, 0xba, 0x14,
	0x3d, 0x40, 0x27, 0x6f, 0x81, 0x87, 0xae, 0xd1, 0x92, 0x84, 0x20, 0x8e, 0xe8, 0x6e, 0xd0, 0x13,
	0xf7, 0x1a, 0xb1, 0xe3, 0x22, 0x9e, 0x84, 0xaf, 0x1f, 0x7e, 0xcc, 0xa2, 0xa0, 0xde, 0x34, 0xd4,
	0x1d, 0xfb, 0x81, 0x0c, 0xe5, 0x31, 0x7f, 0x0e, 0x3f, 0xc0, 0xe4, 0xc6, 0x3d, 0x2f, 0x50, 0xbc,
	0xc8, 0xea, 0xb6, 0x7e, 0x7c, 0x9e, 0xad, 0xad, 0xb7, 0x20, 0x41, 0x41, 0x19, 0x54, 0xd9, 0x54,
	0xef, 0x2e, 0xe6, 0x7b, 0xcc, 0x9a, 0xce, 0x5c, 0xce, 0xde, 0xac, 0x24, 0xa8, 0xb0, 0x0c, 0x2a,
	0xe4, 0x38, 0x91, 0x02, 0x85, 0x5d, 0x9a, 0x50, 0x82, 0x8a, 0xdc, 0x8e, 0x5d, 0xa0, 0x1d, 0xa2,
	0x26, 0x6a, 0x3d, 0x89, 0x24, 0xa8, 0x4d, 0x19, 0x54, 0xa9, 0x6b, 0xf3, 0xca, 0x68, 0x86, 0xa6,
	0x7b, 0x7b, 0x12, 0x4b, 0x50, 0xa9, 0x5b, 0x99, 0xea, 0x7c, 0x8d, 0xfe, 0x9a, 0x7a, 0xf4, 0x26,
	0x91, 0xa0, 0x84, 0xbb, 0x86, 0x23, 0x93, 0xeb, 0x1a, 0x63, 0xfe, 0xa9, 0x13, 0x7e, 0xf0, 0xe9,
	0x1f, 0x00, 0x00, 0xff, 0xff, 0x01, 0x38, 0x80, 0x18, 0x07, 0x01, 0x00, 0x00,
}
